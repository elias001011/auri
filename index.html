<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auri - Chatbot Privado</title>
    <style>
        /* Reset básico e estilos globais */
        :root {
            /* Tema Claro */
            --bg-color-light: #ffffff;
            /* CORREÇÃO: Texto principal preto para tema claro */
            --text-color-light: #000000;
            --sidebar-bg-light: #f9fafb;
            --input-bg-light: #f3f4f6;
            --border-color-light: #e5e7eb;
            --hover-bg-light: #e5e7eb;
            --user-msg-bg-light: #e0f2fe;
            --ai-msg-bg-light: #f3f4f6;
            --overlay-bg-light: rgba(255, 255, 255, 0.7);
            /* CORREÇÃO: Placeholder cinza médio para tema claro */
            --placeholder-color-light: #6b7280;

            /* Tema Escuro (Padrão - Preto Absoluto) */
            --bg-color-dark: #000000;
            /* CORREÇÃO: Texto principal branco para tema escuro */
            --text-color-dark: #ffffff;
            --sidebar-bg-dark: #0a0a0a;
            --input-bg-dark: #111111;
            --border-color-dark: #2a2a2a;
            --hover-bg-dark: #1f1f1f;
            --user-msg-bg-dark: #212c40;
            --ai-msg-bg-dark: #181818;
            --overlay-bg-dark: rgba(0, 0, 0, 0.7);
            /* CORREÇÃO: Placeholder cinza claro para tema escuro */
            --placeholder-color-dark: #9ca3af;

            /* Cores de destaque */
            --accent-color: #3b82f6;
            --accent-text-color: #ffffff;

            /* Fontes e Dimensões */
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            --border-radius: 8px;
            --padding-sm: 8px;
            --padding-md: 16px;
            --padding-lg: 24px;

            /* Inicialmente define as variáveis do tema ESCURO como padrão */
            --bg-color: var(--bg-color-dark);
            --text-color: var(--text-color-dark);
            --sidebar-bg: var(--sidebar-bg-dark);
            --input-bg: var(--input-bg-dark);
            --border-color: var(--border-color-dark);
            --hover-bg: var(--hover-bg-dark);
            --user-msg-bg: var(--user-msg-bg-dark);
            --ai-msg-bg: var(--ai-msg-bg-dark);
            --overlay-bg: var(--overlay-bg-dark);
            --bg-color-rgb: 0, 0, 0;
            /* RGB para overlay */
            /* CORREÇÃO: Define variável placeholder padrão */
            --placeholder-color: var(--placeholder-color-dark);

            /* CORREÇÃO: Sugere esquema de cores para o navegador (influencia scrollbars, etc) */
            color-scheme: dark;
        }

        [data-theme="light"] {
            --bg-color: var(--bg-color-light);
            --text-color: var(--text-color-light);
            --sidebar-bg: var(--sidebar-bg-light);
            --input-bg: var(--input-bg-light);
            --border-color: var(--border-color-light);
            --hover-bg: var(--hover-bg-light);
            --user-msg-bg: var(--user-msg-bg-light);
            --ai-msg-bg: var(--ai-msg-bg-light);
            --overlay-bg: var(--overlay-bg-light);
            --bg-color-rgb: 255, 255, 255;
            /* RGB para overlay */
            /* CORREÇÃO: Define variável placeholder para tema claro */
            --placeholder-color: var(--placeholder-color-light);

            /* CORREÇÃO: Sugere esquema de cores para o navegador */
            color-scheme: light;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            transition: background-color 0.3s, color 0.3s;
        }

        button,
        input,
        textarea,
        select {
            font-family: inherit;
            font-size: inherit;
            color: inherit;
            border-radius: var(--border-radius);
        }

        button {
            cursor: pointer;
            border: none;
            background-color: transparent;
            padding: var(--padding-sm) var(--padding-md);
            transition: background-color 0.2s, opacity 0.2s;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* CORREÇÃO: Estilo global para placeholder */
        input::placeholder,
        textarea::placeholder {
            color: var(--placeholder-color);
            opacity: 1;
            /* Garante visibilidade no Firefox */
        }

        /* CORREÇÃO: Estilo da barra de rolagem para consistência */
        /* Standard */
        :root {
            scrollbar-color: var(--input-bg) var(--bg-color);
            /* thumb track */
            scrollbar-width: thin;
        }

        /* Para navegadores WebKit (Chrome, Safari, Edge) */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background-color: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background-color: var(--input-bg);
            border-radius: 4px;
            border: 2px solid var(--bg-color);
            /* Adiciona pequeno espaçamento */
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--hover-bg);
        }


        /* Layout Principal */
        .app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* --- Barra Lateral --- */
        .sidebar {
            width: 260px;
            background-color: var(--sidebar-bg);
            padding: var(--padding-md);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            transition: width 0.3s ease, padding 0.3s ease, transform 0.3s ease, background-color 0.3s;
            flex-shrink: 0;
            position: relative;
        }

        .sidebar.collapsed {
            width: 0;
            padding: var(--padding-md) 0;
            overflow: hidden;
            border-right: none;
            transform: translateX(-100%);
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            margin-bottom: var(--padding-lg);
            padding-left: 45px;
            /* Espaço para botão toggle */
            position: relative;
            min-height: 30px;
        }

        .sidebar-toggle-button {
            position: absolute;
            top: 15px;
            /* Ajuste a posição conforme necessário */
            left: 10px;
            z-index: 1100;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            font-size: 1.2em;
            line-height: 1;
            transition: transform 0.3s ease, left 0.3s ease, background-color 0.2s;
        }

        .sidebar-toggle-button:hover {
            background-color: var(--hover-bg);
        }

        .sidebar-toggle-button.outside {
            position: fixed;
            left: 10px;
            transform: translateX(0);
        }

        .sidebar-title {
            font-size: 1.4em;
            font-weight: bold;
        }

        .new-chat-button {
            background-color: var(--accent-color);
            color: var(--accent-text-color);
            text-align: center;
            margin-bottom: var(--padding-lg);
            width: 100%;
        }

        .new-chat-button:hover {
            opacity: 0.9;
        }

        .chat-list-container {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: var(--padding-md);
        }

        .chat-list {
            list-style: none;
        }

        .chat-list-item {
            padding: var(--padding-sm) var(--padding-md);
            border-radius: var(--border-radius);
            margin-bottom: var(--padding-sm);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .chat-list-item:hover {
            background-color: var(--hover-bg);
        }

        .chat-list-item.active {
            background-color: var(--input-bg);
        }

        .chat-item-actions {
            display: none;
            /* Oculto por padrão */
            position: absolute;
            right: var(--padding-sm);
            top: 50%;
            transform: translateY(-50%);
            background-color: var(--sidebar-bg);
            /* Para cobrir texto abaixo */
            padding-left: 5px;
        }

        .chat-list-item:hover .chat-item-actions {
            display: flex;
            gap: 5px;
        }

        .chat-item-actions button {
            padding: 3px;
            font-size: 0.9em;
            background: none;
            color: var(--text-color);
            /* Garante visibilidade */
        }

        .settings-button {
            margin-top: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--padding-sm);
            width: 100%;
            border: 1px solid var(--border-color);
        }

        .settings-button:hover {
            background-color: var(--hover-bg);
        }

        /* --- Área de Chat --- */
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .chat-header {
            padding: var(--padding-md);
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message-list-wrapper {
            flex-grow: 1;
            overflow-y: auto;
            padding: var(--padding-lg);
            display: flex;
            flex-direction: column;
        }

        .empty-chat-state {
            text-align: center;
            margin: auto;
            color: #9ca3af;
            /* Mantido cinza para secundário */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .empty-chat-state h2 {
            font-size: 2em;
            margin-bottom: var(--padding-md);
            color: var(--text-color);
        }

        .prompt-suggestions {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
            margin-top: var(--padding-lg);
            width: 80%;
            max-width: 400px;
        }

        /* CORREÇÃO: Garante cor do texto nos botões de sugestão */
        .prompt-suggestions button {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            padding: var(--padding-md);
            text-align: left;
            border-radius: var(--border-radius);
            width: 100%;
            transition: background-color 0.2s;
            color: var(--text-color);
        }

        .prompt-suggestions button:hover {
            background-color: var(--hover-bg);
        }

        .message-list {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: var(--padding-md);
        }

        .message {
            display: flex;
            max-width: 80%;
            position: relative;
        }

        .message.user {
            align-self: flex-end;
        }

        .message.ai {
            align-self: flex-start;
        }

        .message-content {
            padding: var(--padding-sm) var(--padding-md);
            border-radius: var(--border-radius);
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .message.user .message-content img {
            display: block;
            max-width: 100%;
            max-height: 250px;
            border-radius: calc(var(--border-radius) / 2);
            margin-bottom: var(--padding-sm);
            object-fit: contain;
            cursor: pointer;
        }

        .message-content ul,
        .message-content ol {
            margin-left: 25px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 0;
        }

        .message-content li {
            margin-bottom: 4px;
        }

        /* CORREÇÃO: Garante cor texto no pre */
        .message-content pre {
            background-color: var(--input-bg);
            padding: var(--padding-md);
            border-radius: var(--border-radius);
            margin: var(--padding-sm) 0;
            overflow-x: auto;
            border: 1px solid var(--border-color);
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: var(--text-color);
        }

        /* CORREÇÃO: Garante cor texto no code */
        .message-content code {
            font-family: 'Courier New', Courier, monospace;
            color: var(--text-color);
        }

        .message-content code:not(pre code) {
            background-color: var(--input-bg);
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 0.9em;
            border: 1px solid var(--border-color);
        }

        .message-content a {
            color: var(--accent-color);
            text-decoration: underline;
        }

        .message-content a:hover {
            opacity: 0.8;
        }

        .message-content strong {
            font-weight: bold;
        }

        .message-content em {
            font-style: italic;
        }

        /* CORREÇÃO: Simplifica cores das mensagens usando --text-color */
        .message.user .message-content {
            background-color: var(--user-msg-bg);
            color: var(--text-color);
        }

        .message.ai .message-content {
            background-color: var(--ai-msg-bg);
            color: var(--text-color);
        }

        .message-actions {
            position: absolute;
            bottom: -5px;
            right: 5px;
            display: none;
            gap: 5px;
            background-color: rgba(var(--bg-color-rgb), 0.7);
            padding: 2px 5px;
            border-radius: 4px;
            z-index: 1;
        }

        .message:hover .message-actions {
            display: flex;
        }

        .message-actions button {
            padding: 2px 4px;
            font-size: 0.8em;
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .message-actions button:hover {
            background-color: var(--hover-bg);
        }

        .typing-indicator {
            text-align: center;
            padding: var(--padding-sm);
            color: #9ca3af;
            /* Mantido cinza */
            font-style: italic;
            display: none;
        }

        .typing-indicator.visible {
            display: block;
        }

        .chat-footer {
            text-align: center;
            font-size: 0.8em;
            color: #9ca3af;
            /* Mantido cinza */
            padding: var(--padding-sm) 0;
            flex-shrink: 0;
        }

        /* --- Área de Input --- */
        .input-area {
            display: flex;
            flex-direction: column;
            padding: var(--padding-md);
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-color);
            gap: var(--padding-sm);
            flex-shrink: 0;
        }

        .input-row {
            display: flex;
            align-items: flex-end;
            width: 100%;
            gap: var(--padding-sm);
        }

        #attachment-preview-container {
            display: none;
            align-items: center;
            gap: var(--padding-sm);
            padding: var(--padding-sm);
            background-color: var(--input-bg);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            max-width: 100%;
            overflow: hidden;
        }

        #attachment-preview {
            max-height: 50px;
            max-width: 100px;
            border-radius: 4px;
            object-fit: cover;
        }

        #attachment-filename {
            font-size: 0.9em;
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 1;
        }

        #remove-attachment-btn {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.2em;
            padding: 0 5px;
            cursor: pointer;
            margin-left: auto;
            flex-shrink: 0;
        }

        #remove-attachment-btn:hover {
            color: #ef4444;
        }

        /* CORREÇÃO: Garante cor texto input */
        .message-input {
            flex-grow: 1;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--padding-sm) var(--padding-md);
            resize: none;
            min-height: 40px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.4;
            color: var(--text-color);
        }

        .input-button {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            color: var(--text-color);
        }

        .input-button:hover {
            background-color: var(--hover-bg);
        }

        .input-button.send-button {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: var(--accent-text-color);
        }

        .input-button.send-button:hover {
            opacity: 0.9;
            background-color: var(--accent-color);
        }

        .input-button.hidden {
            display: none;
        }

        /* --- Modals / Pop-ups --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--bg-color);
            padding: var(--padding-lg);
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 90%;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--padding-md);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--padding-sm);
        }

        .modal-title {
            font-size: 1.3em;
            font-weight: bold;
        }

        .modal-close-button {
            font-size: 1.8em;
            line-height: 1;
            padding: 0 5px;
            margin: -5px;
            background: none;
            border: none;
            font-weight: bold;
            color: var(--text-color);
        }

        .modal-close-button:hover {
            opacity: 0.7;
        }

        .modal-body {
            margin-bottom: var(--padding-lg);
        }

        #policy-modal-body strong {
            font-weight: bold;
        }

        #policy-modal-body {
            white-space: pre-wrap;
        }

        #generic-modal-body strong {
            font-weight: bold;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--padding-sm);
            border-top: 1px solid var(--border-color);
            padding-top: var(--padding-md);
        }

        .modal-button {
            padding: var(--padding-sm) var(--padding-lg);
            border: 1px solid var(--border-color);
        }

        .modal-button:hover {
            background-color: var(--hover-bg);
        }

        .modal-button.primary {
            background-color: var(--accent-color);
            color: var(--accent-text-color);
            border-color: var(--accent-color);
        }

        .modal-button.primary:hover {
            opacity: 0.9;
            background-color: var(--accent-color);
        }

        .modal-button.danger {
            background-color: #ef4444;
            color: #ffffff;
            border-color: #ef4444;
        }

        .modal-button.danger:hover {
            opacity: 0.9;
            background-color: #ef4444;
        }

        /* Estilos Configurações */
        .settings-section {
            margin-bottom: var(--padding-lg);
        }

        .settings-section h4 {
            margin-bottom: var(--padding-sm);
            font-weight: bold;
        }

        .settings-section label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .settings-section input[type="text"],
        .settings-section select,
        .settings-section textarea {
            width: 100%;
            padding: var(--padding-sm);
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            border-radius: var(--border-radius);
            margin-bottom: var(--padding-sm);
            color: var(--text-color);
        }

        .settings-section select {
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .settings-section select option {
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .settings-section textarea {
            min-height: 80px;
            resize: vertical;
        }

        .settings-section small {
            font-size: 0.8em;
            color: #9ca3af;
            margin-right: 5px;
        }

        .suggestion-btn {
            font-size: 0.8em;
            padding: 2px 6px;
            margin-right: 4px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .suggestion-btn:hover {
            background-color: var(--hover-bg);
        }

        .color-options {
            display: flex;
            gap: var(--padding-sm);
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .color-option.selected {
            border-color: var(--text-color);
        }

        .theme-toggle-button,
        .clear-data-button {
            width: 100%;
            margin-top: var(--padding-sm);
            border: 1px solid var(--border-color);
            padding: var(--padding-sm) var(--padding-md);
        }

        .theme-toggle-button:hover,
        .clear-data-button:hover {
            background-color: var(--hover-bg);
        }

        .clear-data-button {
            border-color: #f87171;
            color: #ef4444;
        }

        [data-theme="dark"] .clear-data-button {
            border-color: #ef4444;
            color: #fca5a5;
        }

        [data-theme="dark"] .clear-data-button:hover {
            background-color: #7f1d1d;
        }

        #message-limit-display {
            font-size: 0.9em;
            color: var(--text-color);
            margin-top: var(--padding-sm);
        }

        .settings-links a {
            color: var(--accent-color);
            text-decoration: none;
            margin-right: var(--padding-md);
            font-size: 0.9em;
        }

        .settings-links a:hover {
            text-decoration: underline;
        }

        /* Overlay de Carregamento e Botão Parar */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-bg);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            flex-direction: column;
            gap: var(--padding-md);
        }

        #loading-overlay.visible {
            display: flex;
        }

        #typing-indicator-overlay {
            font-style: italic;
            color: var(--text-color);
        }

        #stop-generation-btn {
            background-color: #ef4444;
            color: #ffffff;
            border: 1px solid #dc2626;
            padding: var(--padding-sm) var(--padding-lg);
        }

        #stop-generation-btn:hover {
            background-color: #dc2626;
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                z-index: 100;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            }

            .sidebar:not(.collapsed) {
                transform: translateX(0);
            }

            .sidebar.collapsed {
                transform: translateX(-100%);
                width: 260px;
                padding: var(--padding-md);
                border-right: 1px solid var(--border-color);
            }

            .sidebar-toggle-button {
                position: fixed;
                left: 10px;
                top: 10px;
                transform: translateX(0);
                z-index: 1100;
            }

            .sidebar:not(.collapsed) .sidebar-header {
                padding-left: 45px;
            }

            .chat-area {
                width: 100%;
            }

            .message {
                max-width: 90%;
            }

            .modal-content {
                width: 90%;
            }

            .prompt-suggestions {
                width: 90%;
            }
        }

        /* Imagem em Tela Cheia */
        #fullscreen-image-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            cursor: pointer;
        }

        #fullscreen-image-overlay.visible {
            display: flex;
        }

        #fullscreen-image-overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
    </style>
</head>

<body>

    <div class="app-container">
        <button class="sidebar-toggle-button outside" id="sidebar-toggle-btn"
            aria-label="Alternar Barra Lateral">☰</button>
        <aside class="sidebar collapsed" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Auri</div>
            </div>
            <button class="new-chat-button" id="new-chat-btn">+ Novo Chat</button>
            <div class="chat-list-container">
                <ul class="chat-list" id="chat-list"></ul>
            </div>
            <button class="settings-button" id="settings-btn">⚙️ Configurações</button>
        </aside>
        <main class="chat-area">
            <div class="chat-header" id="chat-header">Novo Chat</div>
            <div class="message-list-wrapper" id="message-list-wrapper">
                <div class="empty-chat-state" id="empty-chat-state">
                    <h2 id="greeting">Bom Dia!</h2>
                    <p>Como posso ajudar hoje?</p>
                    <div class="prompt-suggestions" id="prompt-suggestions"></div>
                </div>
                <div class="message-list" id="message-list"></div>
                <div class="typing-indicator" id="typing-indicator">Auri está digitando...</div>
            </div>
            <div class="input-area" id="input-area">
                <div id="attachment-preview-container">
                    <img id="attachment-preview" src="#" alt="Anexo" />
                    <span id="attachment-filename"></span>
                    <button id="remove-attachment-btn" aria-label="Remover Anexo">&times;</button>
                </div>
                <div class="input-row">
                    <button class="input-button attach-button" id="attach-btn" aria-label="Anexar Foto">📎</button>
                    <button class="input-button web-search-button" id="web-search-btn"
                        aria-label="Pesquisa Web">🌐</button>
                    <textarea class="message-input" id="message-input" placeholder="Digite sua mensagem aqui..."
                        rows="1"></textarea>
                    <button class="input-button send-button" id="send-btn" aria-label="Enviar Mensagem">⬆️</button>
                </div>
            </div>
            <div class="chat-footer">Auri pode cometer erros. Focado em privacidade.</div>
        </main>
    </div>

    <div id="loading-overlay">
        <div id="typing-indicator-overlay" style="color: var(--text-color);">Auri está digitando...</div>
        <button id="stop-generation-btn">Parar Geração</button>
    </div>

    <div id="fullscreen-image-overlay">
        <img id="fullscreen-image" src="#" alt="Imagem em tela cheia">
    </div>

    <!-- Modals (Acordo, Configurações, Genérico, Política) -->
    <div class="modal-overlay" id="agreement-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Bem-vindo ao Auri!</h3>
            </div>
            <div class="modal-body">
                <p><strong>Foco em Privacidade:</strong> O Auri foi projetado pensando na sua privacidade. Não exigimos
                    cadastro e seu histórico de conversas e configurações são salvos <strong>apenas no seu
                        dispositivo</strong>.</p>
                <p><strong>APIs de Terceiros:</strong> Para funcionar, o Auri utiliza a API do modelo Gemma 3 via
                    OpenRouter. O uso desse modelo está sujeito aos termos de serviço e políticas de privacidade do
                    OpenRouter. Não podemos garantir 100% de segurança ou privacidade nas interações com essa API
                    externa.</p>
                <p><strong>Gratuito e Experimental:</strong> Este é um projeto gratuito, desenvolvido por uma única
                    pessoa, com orçamento limitado. Isso significa que podem ocorrer instabilidades.</p>
                <p><strong>Termos e Política:</strong> Antes de usar, recomendamos ler nossos <a href="#"
                        id="agreement-terms-link">Termos de Uso</a> e <a href="#" id="agreement-privacy-link">Política
                        de Privacidade</a> para entender como o Auri funciona.</p>
                <p><strong>Ao clicar em "Concordo", você aceita estes termos.</strong></p>
            </div>
            <div class="modal-footer"><button class="modal-button primary" id="agree-btn">Concordo</button></div>
        </div>
    </div>

    <div class="modal-overlay" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Configurações</h3>
                <button class="modal-close-button" data-modal-close="settings-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <h4>Resposta da IA</h4>
                    <label for="ai-lang">Idioma de Resposta da IA:</label>
                    <select id="ai-lang">
                        <option value="auto">Automático</option>
                        <option value="pt">Português</option>
                        <option value="en">English</option>
                        <option value="es">Español</option>
                        <option value="fr">Français</option>
                        <option value="de">Deutsch</option>
                    </select>
                    <label for="user-name">Como a IA pode te chamar (opcional):</label>
                    <input type="text" id="user-name" placeholder="Seu nome ou apelido">
                </div>
                <div class="settings-section">
                    <h4>Instruções Personalizadas (Prompt de Sistema)</h4>
                    <textarea id="custom-instructions"
                        placeholder="Ex: Aja como um assistente prestativo e conciso."></textarea>
                    <div>
                        <small>Sugestões:</small>
                        <button class="suggestion-btn" data-suggestion="+empático">+empático</button>
                        <button class="suggestion-btn" data-suggestion="+formal">+formal</button>
                        <button class="suggestion-btn" data-suggestion="+criativo">+criativo</button>
                    </div>
                </div>
                <div class="settings-section">
                    <h4>Aparência</h4>
                    <label>Cor de Destaque:</label>
                    <div class="color-options" id="color-options">
                        <div class="color-option" data-color="#3b82f6" style="background-color: #3b82f6;" title="Azul">
                        </div>
                        <div class="color-option" data-color="#10b981" style="background-color: #10b981;" title="Verde">
                        </div>
                        <div class="color-option" data-color="#ec4899" style="background-color: #ec4899;" title="Rosa">
                        </div>
                        <div class="color-option" data-color="#8b5cf6" style="background-color: #8b5cf6;" title="Roxo">
                        </div>
                        <div class="color-option" data-color="#f59e0b" style="background-color: #f59e0b;"
                            title="Amarelo"></div>
                    </div>
                    <button class="theme-toggle-button" id="theme-toggle-btn">Alternar para Tema Claro</button>
                </div>
                <div class="settings-section">
                    <h4>Dados</h4>
                    <div id="message-limit-display">Mensagens restantes hoje: 10/10</div>
                    <button class="clear-data-button" id="clear-data-btn">Limpar Todos os Dados Locais</button>
                </div>
                <div class="settings-section settings-links">
                    <h4>Sobre</h4>
                    <a href="#" id="settings-terms-link">Termos de Uso</a>
                    <a href="#" id="settings-privacy-link">Política de Privacidade</a>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-button" data-modal-close="settings-modal">Fechar</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="generic-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="generic-modal-title">Aviso</h3>
                <button class="modal-close-button" data-modal-close="generic-modal">&times;</button>
            </div>
            <div class="modal-body" id="generic-modal-body">
                <p>Conteúdo do modal aqui.</p>
            </div>
            <div class="modal-footer" id="generic-modal-footer">
                <!-- CORREÇÃO: Botão Fechar padrão movido para cá (ainda controlado por JS) -->
                <button class="modal-button" data-modal-close="generic-modal">Fechar</button>
                <!-- Botões customizados serão inseridos aqui pelo JS antes deste botão -->
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="policy-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="policy-modal-title">Documento</h3>
                <button class="modal-close-button" data-modal-close="policy-modal">&times;</button>
            </div>
            <div class="modal-body" id="policy-modal-body">Carregando...</div>
            <div class="modal-footer">
                <button class="modal-button" data-modal-close="policy-modal">Fechar</button>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept="image/*" style="display: none;">

    <script>
        // --- Constantes e Variáveis Globais --- //
        const API_KEYS = {
            openrouter: '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', // Chave de teste
            google_search: 'YOUR_GOOGLE_SEARCH_API_KEY', // Substitua se for usar
            google_search_cx: 'YOUR_GOOGLE_SEARCH_CX' // Substitua se for usar
        };
        const MODEL_ID = 'google/gemma-3-27b-it:free';
        const MODEL_CONFIG = { name: 'Gemma 3 27B (Free)', provider: 'openrouter', supportsImage: true, supportsWebSearch: true, webSearchType: 'suffix' };
        const MAX_DAILY_MESSAGES = 10; // Limite diário

        let state = {
            chats: {},
            currentChatId: null,
            settings: {
                theme: 'dark',
                accentColor: '#3b82f6',
                aiLang: 'auto',
                userName: '',
                customInstructions: '',
                agreedToTerms: false,
                dailyMessageCount: 0,
                lastMessageDate: null
            },
            isAiResponding: false,
            webSearchActive: false,
            attachedImage: null // Guarda a imagem anexada em base64
        };
        let currentRequestController = null;

        // --- Referências do DOM --- //
        const sidebar = document.getElementById('sidebar');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
        const newChatBtn = document.getElementById('new-chat-btn');
        const chatList = document.getElementById('chat-list');
        const settingsBtn = document.getElementById('settings-btn');
        const chatHeader = document.getElementById('chat-header');
        const messageListWrapper = document.getElementById('message-list-wrapper');
        const messageList = document.getElementById('message-list');
        const emptyChatState = document.getElementById('empty-chat-state');
        const greeting = document.getElementById('greeting');
        const promptSuggestions = document.getElementById('prompt-suggestions');
        const typingIndicator = document.getElementById('typing-indicator');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const attachBtn = document.getElementById('attach-btn');
        const webSearchBtn = document.getElementById('web-search-btn');
        const fileInput = document.getElementById('file-input');
        const attachmentPreviewContainer = document.getElementById('attachment-preview-container');
        const attachmentPreview = document.getElementById('attachment-preview');
        const attachmentFilename = document.getElementById('attachment-filename');
        const removeAttachmentBtn = document.getElementById('remove-attachment-btn');
        const agreementModal = document.getElementById('agreement-modal');
        const settingsModal = document.getElementById('settings-modal');
        const genericModal = document.getElementById('generic-modal');
        const policyModal = document.getElementById('policy-modal');
        const agreeBtn = document.getElementById('agree-btn');
        const agreementTermsLink = document.getElementById('agreement-terms-link');
        const agreementPrivacyLink = document.getElementById('agreement-privacy-link');
        const loadingOverlay = document.getElementById('loading-overlay');
        const stopGenerationBtn = document.getElementById('stop-generation-btn');
        const fullscreenImageOverlay = document.getElementById('fullscreen-image-overlay');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const aiLangSelect = document.getElementById('ai-lang');
        const userNameInput = document.getElementById('user-name');
        const customInstructionsTextarea = document.getElementById('custom-instructions');
        const suggestionBtns = document.querySelectorAll('.suggestion-btn');
        const colorOptionsContainer = document.getElementById('color-options');
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const clearDataBtn = document.getElementById('clear-data-btn');
        const settingsTermsLink = document.getElementById('settings-terms-link');
        const settingsPrivacyLink = document.getElementById('settings-privacy-link');
        const messageLimitDisplay = document.getElementById('message-limit-display');

        // --- Traduções (Mantido igual) --- //
        const t = {
            toggleSidebar: "Alternar Barra Lateral", newChat: "+ Novo Chat", settings: "⚙️ Configurações",
            chatHeaderDefault: "Novo Chat", greetingMorning: "Bom Dia!", greetingAfternoon: "Boa Tarde!",
            greetingEvening: "Boa Noite!", greetingHelp: "Como posso ajudar hoje?",
            typingIndicator: "Auri está digitando...", inputPlaceholder: "Digite sua mensagem aqui...",
            inputPlaceholderWaiting: "Aguarde...", sendLabel: "Enviar Mensagem", attachLabel: "Anexar Foto",
            webSearchLabel: "Pesquisa Web", footerNote: "Auri pode cometer erros. Focado em privacidade.",
            welcomeTitle: "Bem-vindo ao Auri!", termsLink: "Termos de Uso", privacyLink: "Política de Privacidade",
            agreeButton: "Concordo", settingsTitle: "Configurações", settingsAiLang: "Idioma de Resposta da IA:",
            settingsAiLangAuto: "Automático", settingsUserName: "Como a IA pode te chamar (opcional):",
            settingsUserNamePlaceholder: "Seu nome ou apelido", settingsCustomInstructions: "Instruções Personalizadas (Prompt de Sistema)",
            settingsCustomInstructionsPlaceholder: "Ex: Aja como um assistente prestativo e conciso.",
            settingsSuggestions: "Sugestões:", settingsAppearance: "Aparência", settingsAccentColor: "Cor de Destaque:",
            settingsThemeToggleLight: "Alternar para Tema Escuro", settingsThemeToggleDark: "Alternar para Tema Claro",
            settingsData: "Dados", settingsClearData: "Limpar Todos os Dados Locais", settingsAbout: "Sobre",
            modalClose: "Fechar", modalConfirm: "Confirmar", modalCancel: "Cancelar", modalErrorTitle: "Erro",
            modalWarningTitle: "Aviso", modalInfoTitle: "Informação", modalSuccessTitle: "Sucesso",
            modalConfirmDeleteTitle: "Confirmar Exclusão", modalConfirmDeleteBody: "Tem certeza que deseja excluir o chat \"{chatName}\"? Esta ação não pode ser desfeita.",
            modalConfirmDeleteButton: "Confirmar Exclusão", modalConfirmClearDataTitle: "Confirmar Limpeza de Dados",
            modalConfirmClearDataBody: "<strong>Atenção!</strong> Tem certeza que deseja limpar TODOS os seus chats e configurações salvos localmente? Esta ação é irreversível.",
            modalConfirmClearDataButton: "Confirmar Limpeza", modalRenameTitle: "Renomear Chat",
            modalRenameLabel: "Novo nome para \"{chatName}\":", modalRenameSave: "Salvar", modalRenameErrorEmpty: "O nome do chat não pode ficar vazio.",
            modalLimitTitle: "Limite Atingido", modalLimitBody: "Você atingiu o limite de {limit} mensagens hoje. Por favor, volte amanhã.",
            modalLimitWarningTitle: "Aviso de Limite", modalLimitWarningBody: "Você tem {remaining} mensagens restantes hoje.",
            modalApiError: "Desculpe, ocorreu um erro ao processar sua solicitação: {error}. Tente novamente.",
            modalApiRegenError: "Erro ao regenerar: {error}. A resposta anterior foi mantida.", modalCopySuccess: "Copiado!",
            modalCopyError: "Não foi possível copiar o texto.", modalFileReadError: "Não foi possível ler o arquivo.",
            modalInvalidFileError: "Selecione um arquivo de imagem válido.", modalGenericError: "Ocorreu um erro inesperado.",
            chatItemRename: "Renomear Chat", chatItemDelete: "Excluir Chat", messageCopy: "Copiar",
            messageRegenerate: "Regerar", removeAttachment: "Remover Anexo", colorBlue: "Azul", colorGreen: "Verde",
            colorPink: "Rosa", colorPurple: "Roxo", colorYellow: "Amarelo", stopGeneration: "Parar Geração",
            generationStopped: "Geração interrompida pelo usuário.", messageLimitStatus: "Mensagens restantes hoje: {remaining}/{total}"
        };

        const applyTranslations = () => {
            const setText = (selector, key, prop = 'textContent') => { const el = document.querySelector(selector); if (el && t[key]) el[prop] = t[key]; };
            const setAttr = (selector, key, attr) => { const el = document.querySelector(selector); if (el && t[key]) el.setAttribute(attr, t[key]); };
            document.documentElement.lang = 'pt-BR';
            setAttr('#sidebar-toggle-btn', 'toggleSidebar', 'aria-label'); setText('#new-chat-btn', 'newChat'); setText('#settings-btn', 'settings');
            setText('#empty-chat-state p', 'greetingHelp'); setText('#typing-indicator', 'typingIndicator'); setAttr('#message-input', 'inputPlaceholder', 'placeholder');
            setAttr('#send-btn', 'sendLabel', 'aria-label'); setAttr('#attach-btn', 'attachLabel', 'aria-label'); setAttr('#web-search-btn', 'webSearchLabel', 'aria-label');
            setText('.chat-footer', 'footerNote'); setAttr('#remove-attachment-btn', 'removeAttachment', 'aria-label');
            setText('#agreement-modal .modal-title', 'welcomeTitle'); setText('#agree-btn', 'agreeButton');
            setText('#agreement-terms-link', 'termsLink'); setText('#agreement-privacy-link', 'privacyLink');
            setText('#settings-modal .modal-title', 'settingsTitle'); setText('label[for="ai-lang"]', 'settingsAiLang');
            setText('#ai-lang option[value="auto"]', 'settingsAiLangAuto');
            setText('#ai-lang option[value="pt"]', undefined, 'Português'); setText('#ai-lang option[value="en"]', undefined, 'English');
            setText('#ai-lang option[value="es"]', undefined, 'Español'); setText('#ai-lang option[value="fr"]', undefined, 'Français'); setText('#ai-lang option[value="de"]', undefined, 'Deutsch');
            setText('label[for="user-name"]', 'settingsUserName'); setAttr('#user-name', 'settingsUserNamePlaceholder', 'placeholder');
            document.querySelectorAll('#settings-modal .settings-section h4').forEach(h4 => {
                const content = h4.textContent.toLowerCase();
                if (content.includes('resposta')) h4.textContent = 'Resposta da IA';
                else if (content.includes('instruções')) h4.textContent = t.settingsCustomInstructions;
                else if (content.includes('aparência')) h4.textContent = t.settingsAppearance;
                else if (content.includes('dados')) h4.textContent = t.settingsData;
                else if (content.includes('sobre')) h4.textContent = t.settingsAbout;
            });
            const colorLabel = document.querySelector('#settings-modal .settings-section label:not([for])'); if (colorLabel) colorLabel.textContent = t.settingsAccentColor;
            setAttr('#custom-instructions', 'settingsCustomInstructionsPlaceholder', 'placeholder');
            setText('#theme-toggle-btn', state.settings.theme === 'dark' ? t.settingsThemeToggleDark : t.settingsThemeToggleLight);
            setText('#clear-data-btn', 'settingsClearData'); setText('#settings-terms-link', 'termsLink'); setText('#settings-privacy-link', 'privacyLink');
            const settingsCloseBtn = document.querySelector('#settings-modal .modal-footer button[data-modal-close]'); if (settingsCloseBtn) settingsCloseBtn.textContent = t.modalClose;
            setAttr('.color-option[data-color="#3b82f6"]', 'colorBlue', 'title'); setAttr('.color-option[data-color="#10b981"]', 'colorGreen', 'title');
            setAttr('.color-option[data-color="#ec4899"]', 'colorPink', 'title'); setAttr('.color-option[data-color="#8b5cf6"]', 'colorPurple', 'title');
            setAttr('.color-option[data-color="#f59e0b"]', 'colorYellow', 'title');
            setText('#greeting', t[getGreetingKey()]); setText('#stop-generation-btn', 'stopGeneration'); updateMessageLimitDisplay();
        };

        // --- Funções Utilitárias --- //
        const saveState = () => { try { localStorage.setItem('auriState', JSON.stringify(state)); } catch (e) { console.error("Erro ao salvar estado:", e); showModal(t.modalErrorTitle, 'Falha ao salvar dados no armazenamento local.'); } };
        const loadState = () => { try { const saved = localStorage.getItem('auriState'); if (saved) { const parsed = JSON.parse(saved); const { selectedModel, interfaceLang, ...settings } = parsed.settings || {}; state = { ...state, ...parsed, settings: { ...state.settings, ...settings, theme: settings.theme || 'dark' }, chats: typeof parsed.chats === 'object' && parsed.chats !== null ? parsed.chats : {} }; if (typeof state.settings.agreedToTerms !== 'boolean') state.settings.agreedToTerms = false; checkDailyLimit(false); } } catch (e) { console.error("Erro ao carregar estado:", e); showModal(t.modalErrorTitle, 'Falha ao carregar dados. Estado será reiniciado.'); state.settings.agreedToTerms = false; } };
        const generateId = () => `chat_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

        const showModal = (titleKey, bodyContent, footerButtons = [], modalId = 'generic-modal') => {
            const modal = document.getElementById(modalId); if (!modal) return;
            const modalTitle = modal.querySelector('.modal-title');
            const modalBody = modal.querySelector('.modal-body');
            const modalFooter = modal.querySelector('.modal-footer');
            // CORREÇÃO: Seleciona o botão de fechar especificamente DENTRO do footer
            const defaultCloseButton = modal.querySelector('.modal-footer [data-modal-close]');

            if (modalTitle) modalTitle.textContent = t[titleKey] || titleKey;
            if (modalBody) modalBody.innerHTML = bodyContent;

            if (modalFooter) {
                // Remove botões customizados antigos (exceto o de fechar padrão)
                modalFooter.querySelectorAll('.modal-button:not([data-modal-close])').forEach(btn => btn.remove());

                // Adiciona novos botões
                footerButtons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.textContent = t[btnConfig.text] || btnConfig.text;
                    button.classList.add('modal-button');
                    if (btnConfig.class) button.classList.add(...btnConfig.class.split(' '));
                    button.onclick = (event) => {
                        event.stopPropagation();
                        if (btnConfig.onClick) btnConfig.onClick();
                    };

                    // CORREÇÃO: Tenta inserir ANTES do botão fechar padrão, SE ele existir DENTRO do footer, com fallback
                    if (defaultCloseButton && modalFooter.contains(defaultCloseButton)) {
                        try {
                            modalFooter.insertBefore(button, defaultCloseButton);
                        } catch (e) {
                            console.error("Erro ao inserir botão antes do botão de fechar:", e, "Adicionando ao final.");
                            modalFooter.appendChild(button); // Fallback
                        }
                    } else {
                        modalFooter.appendChild(button); // Fallback se não houver botão fechar ou não for filho
                    }
                });

                // Controla visibilidade do botão 'Fechar' padrão (se existir)
                if (defaultCloseButton) {
                    const hasCustomButtons = footerButtons.length > 0;
                    const isSpecialModal = modalId === 'settings-modal' || modalId === 'policy-modal';
                    // Esconde botão 'Fechar' padrão se houver botões customizados E NÃO for um modal especial
                    defaultCloseButton.style.display = (!hasCustomButtons || isSpecialModal) ? 'inline-flex' : 'none';
                    defaultCloseButton.textContent = t.modalClose || 'Fechar';
                }
            }
            modal.classList.add('visible');
        };

        const closeModal = (modalId) => { const modal = document.getElementById(modalId); if (modal) modal.classList.remove('visible'); };
        const getGreetingKey = () => { const h = new Date().getHours(); return h < 12 ? 'greetingMorning' : h < 18 ? 'greetingAfternoon' : 'greetingEvening'; };
        const getRandomSuggestions = (count = 4) => { const allSuggestions = ['Me explique computação quântica em termos simples.', 'Qual a receita de bolo de chocolate?', 'Escreva um poema sobre a chuva.', 'Quais as últimas notícias sobre IA?', 'Dê ideias para umas férias em família.', 'Como funciona o armazenamento local do navegador?', 'Crie uma história curta de ficção científica.', 'Liste os prós e contras de trabalhar remotamente.', 'Sugira 3 filmes de ficção científica lançados nos últimos 5 anos.', 'Quais são os benefícios da meditação?', 'Como posso melhorar minha concentração ao estudar?', 'Resuma o conceito de "machine learning".']; return allSuggestions.sort(() => 0.5 - Math.random()).slice(0, count); };

        const applyTheme = (theme) => {
            document.body.dataset.theme = theme;
            themeToggleBtn.textContent = theme === 'dark' ? t.settingsThemeToggleDark : t.settingsThemeToggleLight;
            state.settings.theme = theme;
            // CORREÇÃO: Aplica color-scheme ao :root para influenciar elementos do navegador como scrollbar
            document.documentElement.style.colorScheme = theme;
            // CORREÇÃO: Chamada removida, CSS global cuida da cor do texto
            // updateUserMessageTextColor();
            const root = document.documentElement;
            root.style.setProperty('--bg-color-rgb', theme === 'dark' ? '0, 0, 0' : '255, 255, 255');
        };

        const applyAccentColor = (color) => {
            document.documentElement.style.setProperty('--accent-color', color);
            const hex = color.replace('#', ''); const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16);
            const lum = (0.299 * r + 0.587 * g + 0.114 * b) / 255; const txtColor = lum > 0.5 ? '#000000' : '#ffffff';
            document.documentElement.style.setProperty('--accent-text-color', txtColor);
            state.settings.accentColor = color;
            document.querySelectorAll('.color-option').forEach(opt => opt.classList.toggle('selected', opt.dataset.color === color));
        };

        // CORREÇÃO: Função removida, CSS global cuida da cor do texto
        // const updateUserMessageTextColor = () => { ... };

        const checkDailyLimit = (showAlert = true) => {
            const today = new Date().toDateString();
            if (state.settings.lastMessageDate !== today) {
                state.settings.dailyMessageCount = 0; state.settings.lastMessageDate = today; saveState(); updateMessageLimitDisplay();
            }
            const remaining = MAX_DAILY_MESSAGES - state.settings.dailyMessageCount;
            if (remaining <= 0) { if (showAlert) showModal('modalLimitTitle', t.modalLimitBody.replace('{limit}', MAX_DAILY_MESSAGES)); return false; }
            if (remaining <= 3 && remaining > 0 && showAlert) { showModal('modalLimitWarningTitle', t.modalLimitWarningBody.replace('{remaining}', remaining)); }
            return true;
        };
        const incrementMessageCount = () => {
            const today = new Date().toDateString();
            if (state.settings.lastMessageDate !== today) { state.settings.dailyMessageCount = 1; state.settings.lastMessageDate = today; } else { state.settings.dailyMessageCount++; }
            saveState(); updateMessageLimitDisplay();
        };
        const updateMessageLimitDisplay = () => {
            const today = new Date().toDateString(); if (state.settings.lastMessageDate !== today) { state.settings.dailyMessageCount = 0; }
            const remaining = Math.max(0, MAX_DAILY_MESSAGES - state.settings.dailyMessageCount);
            if (messageLimitDisplay) { messageLimitDisplay.textContent = t.messageLimitStatus.replace('{remaining}', remaining).replace('{total}', MAX_DAILY_MESSAGES); }
        };

        // --- Funções de Renderização --- //
        const renderChatList = () => {
            chatList.innerHTML = '';
            const sortedIds = Object.keys(state.chats).sort((a, b) => state.chats[b].createdAt - state.chats[a].createdAt);
            if (sortedIds.length === 0 && !state.currentChatId) { return; }
            sortedIds.forEach(chatId => {
                const chat = state.chats[chatId]; const li = document.createElement('li'); li.classList.add('chat-list-item'); li.dataset.chatId = chatId; if (chatId === state.currentChatId) li.classList.add('active');
                const nameSpan = document.createElement('span'); nameSpan.textContent = chat.name; nameSpan.style.overflow = 'hidden'; nameSpan.style.textOverflow = 'ellipsis'; nameSpan.style.whiteSpace = 'nowrap'; nameSpan.style.flexGrow = '1'; nameSpan.style.marginRight = '50px';
                const actionsDiv = document.createElement('div'); actionsDiv.classList.add('chat-item-actions');
                const renameBtn = document.createElement('button'); renameBtn.textContent = '✏️'; renameBtn.ariaLabel = t.chatItemRename;
                renameBtn.addEventListener('click', (e) => { e.stopPropagation(); renameChat(chatId); });
                const deleteBtn = document.createElement('button'); deleteBtn.textContent = '🗑️'; deleteBtn.ariaLabel = t.chatItemDelete;
                deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteChat(chatId); });
                actionsDiv.appendChild(renameBtn); actionsDiv.appendChild(deleteBtn); li.appendChild(nameSpan); li.appendChild(actionsDiv);
                li.addEventListener('click', () => { selectChat(chatId); }); chatList.appendChild(li);
            });
        };
        const renderMessages = (chatId) => {
            messageList.innerHTML = ''; const chat = state.chats[chatId];
            if (!chat || chat.messages.length === 0) { emptyChatState.style.display = 'flex'; messageList.style.display = 'none'; greeting.textContent = t[getGreetingKey()]; renderPromptSuggestions(); }
            else { emptyChatState.style.display = 'none'; messageList.style.display = 'flex'; chat.messages.forEach(msg => appendMessage(msg)); scrollToBottom(); }
            chatHeader.textContent = chat ? chat.name : t.chatHeaderDefault; updateInputButtonsState();
        };
        const appendMessage = (message) => {
            const { role, content, imageBase64 } = message; const messageElement = document.createElement('div'); messageElement.classList.add('message', role);
            const contentElement = document.createElement('div'); contentElement.classList.add('message-content');
            if (role === 'user' && imageBase64) { const imgElement = document.createElement('img'); imgElement.src = imageBase64; imgElement.alt = "Anexo enviado"; imgElement.addEventListener('click', () => showFullscreenImage(imageBase64)); contentElement.appendChild(imgElement); }
            if (content) { const textElement = document.createElement('div'); textElement.innerHTML = renderMarkdown(content); /* CORREÇÃO: Usa markdown melhorado */ contentElement.appendChild(textElement); }
            const actionsElement = document.createElement('div'); actionsElement.classList.add('message-actions');
            const copyBtn = document.createElement('button'); copyBtn.textContent = '📋'; copyBtn.ariaLabel = t.messageCopy; copyBtn.onclick = () => copyToClipboard(content || ''); actionsElement.appendChild(copyBtn);
            if (role === 'ai' && state.chats[state.currentChatId]?.messages.length > 1) { const regenBtn = document.createElement('button'); regenBtn.textContent = '🔄'; regenBtn.ariaLabel = t.messageRegenerate; regenBtn.onclick = () => regenerateLastAiResponse(); actionsElement.appendChild(regenBtn); }
            messageElement.appendChild(contentElement); messageElement.appendChild(actionsElement); messageList.appendChild(messageElement);
            // CORREÇÃO: Chamada removida, CSS global cuida da cor do texto
            // if (role === 'user') { updateUserMessageTextColor(); }
            if (messageList.children.length > 0) { emptyChatState.style.display = 'none'; messageList.style.display = 'flex'; }
            scrollToBottom();
        };
        const renderMarkdown = (text) => {
            // CORREÇÃO: Conversor Markdown melhorado (escape de HTML em code/pre, melhor tratamento de <br>)
            if (!text) return '';
            // Função auxiliar para escapar HTML
            const escapeHtml = (unsafe) => unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");

            let html = text;
            // 1. Processar blocos de código primeiro para evitar processar markdown dentro deles
            const codeBlocks = [];
            html = html.replace(/``````/gs, (match, lang, code) => {
                const index = codeBlocks.length;
                const escapedCode = escapeHtml(code.trim()); // Escapa HTML dentro do código
                codeBlocks.push(`<pre><code class="language-${lang || ''}">${escapedCode}</code></pre>`);
                return `%%%CODEBLOCK${index}%%%`; // Marcador temporário
            });
            // 2. Escapar HTML básico no restante do texto
            html = escapeHtml(html);
            // 3. Processar outros markdowns
            html = html.replace(/^---\s*$/gm, '<hr>').replace(/^\*\*\*\s*$/gm, '<hr>').replace(/^___\s*$/gm, '<hr>');
            html = html.replace(/^###### (.*$)/gm, '<h6>$1</h6>').replace(/^##### (.*$)/gm, '<h5>$1</h5>').replace(/^#### (.*$)/gm, '<h4>$1</h4>').replace(/^### (.*$)/gm, '<h3>$1</h3>').replace(/^## (.*$)/gm, '<h2>$1</h2>').replace(/^# (.*$)/gm, '<h1>$1</h1>');
            html = html.replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>'); html = html.replace(/<\/blockquote>\n?<blockquote>/g, '\n');
            html = html.replace(/^\s*([-*+])\s+(.*$)/gm, (m, _, item) => `<li>${item}</li>`); html = html.replace(/(?:^<li>.*<\/li>\s*)+/gm, match => `<ul>\n${match.trim()}\n</ul>\n`);
            html = html.replace(/^\s*(\d+)\.\s+(.*$)/gm, (m, num, item) => `<li value="${num}">${item}</li>`); html = html.replace(/(?:^<li value="\d+">.*<\/li>\s*)+/gm, match => `<ol>\n${match.trim()}\n</ol>\n`);
            html = html.replace(/<\/ul>\s*<ul>/g, '</ul><ul>'); html = html.replace(/<\/ol>\s*<ol>/g, '</ol><ol>');
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            html = html.replace(/\*\*([^\s*].*?[^\s*])\*\*/g, '<strong>$1</strong>').replace(/__([^\s_].*?[^\s_])__/g, '<strong>$1</strong>');
            html = html.replace(/(?<!\*)\*([^\s*].*?[^\s*])\*(?!\*)/g, '<em>$1</em>').replace(/(?<!_)_([^\s_].*?[^\s_])_(?!_)/g, '<em>$1</em>');
            // Código inline (escapa HTML)
            html = html.replace(/`([^`]+)`/g, (m, code) => `<code>${escapeHtml(code)}</code>`);
            // 4. Processar parágrafos e <br>
            html = html.split(/\n{2,}/).map(p => {
                const trimmed = p.trim(); if (!trimmed) return '';
                // Não envolve se já for bloco conhecido ou marcador
                if (/^\s*<(pre|ul|ol|li|blockquote|h[1-6]|hr|p|div)|%%%CODEBLOCK/.test(trimmed)) {
                    // Se não for <pre> ou codeblock, converte \n interno em <br>
                    if (!/^\s*<(pre)|%%%CODEBLOCK/.test(trimmed)) {
                        return trimmed.replace(/\n(?!<(ul|ol|li|blockquote|pre|p|h[1-6]|hr|div))/g, '<br>');
                    }
                    return trimmed;
                }
                return `<p>${trimmed.replace(/\n/g, '<br>')}</p>`;
            }).join('\n');
            // 5. Restaurar blocos de código
            html = html.replace(/%%%CODEBLOCK(\d+)%%%/g, (match, index) => codeBlocks[parseInt(index)]);
            // 6. Limpeza final de <br>s
            html = html.replace(/<br>\s*(<(ul|ol|li|blockquote|pre|p|h[1-6]|hr|div))/gi, '$1');
            html = html.replace(/(<\/(ul|ol|blockquote|pre|p|h[1-6]|hr|div)>)\s*<br>/gi, '$1');
            html = html.replace(/<li>\s*<br>/gi, '<li>').replace(/<br>\s*<\/li>/gi, '</li>');

            return html.trim();
        };
        const renderPromptSuggestions = () => {
            promptSuggestions.innerHTML = ''; const suggestions = getRandomSuggestions(4);
            suggestions.forEach(s => { const btn = document.createElement('button'); btn.textContent = s; btn.onclick = () => { messageInput.value = s; handleSendMessage(); }; promptSuggestions.appendChild(btn); });
        };
        const updateInputButtonsState = () => {
            const model = MODEL_CONFIG; const hasText = messageInput.value.trim() !== ''; const hasAttachment = !!state.attachedImage;
            attachBtn.classList.toggle('hidden', !model.supportsImage); attachBtn.disabled = state.isAiResponding;
            webSearchBtn.classList.toggle('hidden', !model.supportsWebSearch); webSearchBtn.disabled = state.isAiResponding;
            webSearchBtn.style.backgroundColor = state.webSearchActive ? 'var(--accent-color)' : 'var(--input-bg)'; webSearchBtn.style.color = state.webSearchActive ? 'var(--accent-text-color)' : 'var(--text-color)';
            messageInput.disabled = state.isAiResponding; messageInput.placeholder = state.isAiResponding ? t.inputPlaceholderWaiting : t.inputPlaceholder;
            sendBtn.disabled = state.isAiResponding || (!hasText && !hasAttachment);
        };
        const scrollToBottom = () => { messageListWrapper.scrollTop = messageListWrapper.scrollHeight; };
        const adjustTextareaHeight = () => { messageInput.style.height = 'auto'; const minH = 40; const scrollH = messageInput.scrollHeight; messageInput.style.height = `${Math.max(minH, scrollH)}px`; };
        const showFullscreenImage = (src) => { fullscreenImage.src = src; fullscreenImageOverlay.classList.add('visible'); };
        const hideFullscreenImage = () => { fullscreenImageOverlay.classList.remove('visible'); fullscreenImage.src = '#'; };

        // --- Funções de Lógica do Chat --- //
        const createNewChat = (save = true) => {
            const newChatId = generateId(); const existingChats = Object.keys(state.chats).length; const newChatName = `${t.chatHeaderDefault} ${existingChats + 1}`;
            state.chats[newChatId] = { id: newChatId, name: newChatName, messages: [], createdAt: Date.now() }; state.currentChatId = newChatId; state.webSearchActive = false; removeAttachment();
            renderChatList(); renderMessages(newChatId); if (save) { saveState(); }
            messageInput.value = ''; adjustTextareaHeight(); updateInputButtonsState(); messageInput.focus();
        };
        const selectChat = (chatId) => {
            if (chatId === state.currentChatId || !state.chats[chatId]) return;
            state.currentChatId = chatId; state.webSearchActive = false; removeAttachment();
            renderChatList(); renderMessages(chatId);
            messageInput.value = ''; adjustTextareaHeight(); updateInputButtonsState(); messageInput.focus();
        };
        const renameChat = (chatId) => {
            const chat = state.chats[chatId]; if (!chat) return;
            const bodyHtml = `<label for="new-chat-name-input">${t.modalRenameLabel.replace('{chatName}', chat.name)}</label><input type="text" id="new-chat-name-input" value="${chat.name}" style="width: 100%; margin-top: 5px; padding: 8px; border: 1px solid var(--border-color); background-color: var(--input-bg); border-radius: var(--border-radius); color: var(--text-color);">`;
            const footerButtons = [
                { text: 'modalCancel', class: '', onClick: () => closeModal('generic-modal') },
                {
                    text: 'modalRenameSave', class: 'primary', onClick: () => {
                        const inputEl = document.getElementById('new-chat-name-input'); const newName = inputEl ? inputEl.value.trim() : '';
                        if (newName && newName !== chat.name) { state.chats[chatId].name = newName; saveState(); renderChatList(); if (chatId === state.currentChatId) { chatHeader.textContent = newName; } closeModal('generic-modal'); }
                        else if (!newName) { showModal('modalErrorTitle', t.modalRenameErrorEmpty); }
                        else { closeModal('generic-modal'); }
                    }
                }
            ];
            showModal('modalRenameTitle', bodyHtml, footerButtons, 'generic-modal');
            setTimeout(() => { const inputEl = document.getElementById('new-chat-name-input'); if (inputEl) { inputEl.focus(); inputEl.select(); } }, 100);
        };
        const deleteChat = (chatId) => {
            const chat = state.chats[chatId]; if (!chat) return;
            const footerButtons = [
                { text: 'modalCancel', class: '', onClick: () => closeModal('generic-modal') },
                {
                    text: 'modalConfirmDeleteButton', class: 'danger', onClick: () => {
                        delete state.chats[chatId];
                        if (state.currentChatId === chatId) { const remainingIds = Object.keys(state.chats).sort((a, b) => state.chats[b].createdAt - state.chats[a].createdAt); if (remainingIds.length > 0) { selectChat(remainingIds[0]); } else { createNewChat(); } }
                        else { renderChatList(); }
                        saveState(); closeModal('generic-modal');
                    }
                }
            ];
            showModal('modalConfirmDeleteTitle', t.modalConfirmDeleteBody.replace('{chatName}', chat.name), footerButtons, 'generic-modal');
        };
        const handleSendMessage = async () => {
            const messageText = messageInput.value.trim(); const imageToSend = state.attachedImage;
            if (!messageText && !imageToSend || state.isAiResponding || !checkDailyLimit()) return;
            if (!state.currentChatId || !state.chats[state.currentChatId]) { createNewChat(true); /* Garante que chat existe antes de prosseguir */ }
            const currentChat = state.chats[state.currentChatId]; // Garante que temos a referência correta
            const userMessageObj = { role: 'user', content: messageText, imageBase64: imageToSend };
            appendMessage(userMessageObj); currentChat.messages.push(userMessageObj);
            messageInput.value = ''; adjustTextareaHeight(); removeAttachment();
            state.isAiResponding = true; loadingOverlay.classList.add('visible'); updateInputButtonsState(); scrollToBottom();
            const apiMessages = currentChat.messages.map(msg => {
                if (msg.role === 'user') {
                    const contentPayload = []; if (msg.content) contentPayload.push({ type: 'text', text: msg.content });
                    if (msg.imageBase64 && MODEL_CONFIG.supportsImage) { const base64Data = msg.imageBase64.startsWith('data:') ? msg.imageBase64.split(',')[1] : msg.imageBase64; contentPayload.push({ type: 'image_url', image_url: { url: msg.imageBase64.startsWith('data:') ? msg.imageBase64 : `data:image/jpeg;base64,${base64Data}` } }); }
                    if (contentPayload.length === 0) return null; if (contentPayload.length === 1 && contentPayload[0].type === 'text') return { role: 'user', content: contentPayload[0].text }; return { role: 'user', content: contentPayload };
                } return { role: 'assistant', content: msg.content };
            }).filter(msg => msg !== null);
            incrementMessageCount(); currentRequestController = new AbortController();
            try {
                const aiResponseContent = await callApi(apiMessages, state.webSearchActive, currentRequestController.signal);
                const aiMessage = { role: 'ai', content: aiResponseContent }; currentChat.messages.push(aiMessage); appendMessage(aiMessage);
            } catch (error) {
                console.error("Erro na chamada da API:", error); let errorMessageContent = error.name === 'AbortError' ? t.generationStopped : t.modalApiError.replace('{error}', error.message);
                const errorMessageObj = { role: 'ai', content: errorMessageContent }; currentChat.messages.push(errorMessageObj); appendMessage(errorMessageObj);
            } finally { state.isAiResponding = false; loadingOverlay.classList.remove('visible'); updateInputButtonsState(); saveState(); scrollToBottom(); messageInput.focus(); currentRequestController = null; }
        };
        const regenerateLastAiResponse = async () => {
            if (state.isAiResponding) return; const currentChat = state.chats[state.currentChatId]; if (!currentChat || currentChat.messages.length < 1) return;
            let lastAiIndex = -1; for (let i = currentChat.messages.length - 1; i >= 0; i--) { if (currentChat.messages[i].role === 'ai') { lastAiIndex = i; break; } }
            if (lastAiIndex === -1 || lastAiIndex !== currentChat.messages.length - 1 || !checkDailyLimit()) return;
            const originalAiMessage = currentChat.messages.pop();
            const msgElements = messageList.querySelectorAll('.message'); if (msgElements.length > 0) { msgElements[msgElements.length - 1].remove(); } else { console.warn("Desincronização UI/Estado ao tentar regenerar. Recarregando mensagens."); renderMessages(state.currentChatId); return; }
            const apiMessages = currentChat.messages.map(msg => {
                if (msg.role === 'user') {
                    const contentPayload = []; if (msg.content) contentPayload.push({ type: 'text', text: msg.content });
                    if (msg.imageBase64 && MODEL_CONFIG.supportsImage) { const base64Data = msg.imageBase64.startsWith('data:') ? msg.imageBase64.split(',')[1] : msg.imageBase64; contentPayload.push({ type: 'image_url', image_url: { url: msg.imageBase64.startsWith('data:') ? msg.imageBase64 : `data:image/jpeg;base64,${base64Data}` } }); }
                    if (contentPayload.length === 0) return null; if (contentPayload.length === 1 && contentPayload[0].type === 'text') return { role: 'user', content: contentPayload[0].text }; return { role: 'user', content: contentPayload };
                } return { role: 'assistant', content: msg.content };
            }).filter(msg => msg !== null);
            state.isAiResponding = true; loadingOverlay.classList.add('visible'); updateInputButtonsState(); scrollToBottom(); incrementMessageCount(); currentRequestController = new AbortController();
            try {
                const aiResponseContent = await callApi(apiMessages, false, currentRequestController.signal); const newAiMessage = { role: 'ai', content: aiResponseContent }; currentChat.messages.push(newAiMessage); appendMessage(newAiMessage);
            } catch (error) {
                console.error("Erro ao regenerar:", error); let errorMessageContent = error.name === 'AbortError' ? t.generationStopped : t.modalApiRegenError.replace('{error}', error.message);
                if (error.name !== 'AbortError') { currentChat.messages.push(originalAiMessage); appendMessage(originalAiMessage); console.error("Regeneração falhou, resposta original restaurada."); } // Só restaura se não foi abortado
                else { const errorMessageObj = { role: 'ai', content: errorMessageContent }; currentChat.messages.push(errorMessageObj); appendMessage(errorMessageObj); } // Adiciona msg de erro se foi abortado
            } finally { state.isAiResponding = false; loadingOverlay.classList.remove('visible'); updateInputButtonsState(); saveState(); scrollToBottom(); messageInput.focus(); currentRequestController = null; }
        };
        const copyToClipboard = (text) => {
            navigator.clipboard.writeText(text).then(() => { const temp = document.createElement('div'); temp.textContent = t.modalCopySuccess; temp.style.cssText = 'position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:var(--accent-color); color:var(--accent-text-color); padding:5px 10px; border-radius:4px; z-index:2000; font-size: 0.9em;'; document.body.appendChild(temp); setTimeout(() => temp.remove(), 1500); }).catch(err => { console.error('Erro ao copiar:', err); showModal(t.modalErrorTitle, t.modalCopyError); });
        };
        const handleFileUpload = (event) => {
            const file = event.target.files[0]; if (!file) return;
            if (file.type.startsWith('image/')) { const reader = new FileReader(); reader.onloadend = () => { state.attachedImage = reader.result; attachmentPreview.src = reader.result; attachmentFilename.textContent = file.name.length > 25 ? file.name.substring(0, 22) + '...' : file.name; attachmentPreviewContainer.style.display = 'flex'; updateInputButtonsState(); messageInput.focus(); }; reader.onerror = (err) => { console.error("Erro ao ler arquivo:", err); showModal(t.modalErrorTitle, t.modalFileReadError); removeAttachment(); }; reader.readAsDataURL(file); }
            else { showModal(t.modalErrorTitle, t.modalInvalidFileError); removeAttachment(); }
            event.target.value = null;
        };
        const removeAttachment = () => { state.attachedImage = null; attachmentPreview.src = '#'; attachmentFilename.textContent = ''; attachmentPreviewContainer.style.display = 'none'; updateInputButtonsState(); };

        // --- Funções de Chamada de API (Mantido igual) --- //
        const callApi = async (formattedMessages, useWebSearch, signal) => {
            const modelConfig = MODEL_CONFIG; const modelId = MODEL_ID; let endpoint = ''; let headers = { 'Content-Type': 'application/json' }; let body = {}; let systemContent = state.settings.customInstructions || ''; if (state.settings.userName) systemContent += (systemContent ? '\n' : '') + `O nome do usuário é ${state.settings.userName}.`; if (state.settings.aiLang !== 'auto') systemContent += (systemContent ? '\n' : '') + `Responda no idioma: ${state.settings.aiLang}.`;
            const finalApiMessages = []; if (systemContent.trim()) { finalApiMessages.push({ role: 'system', content: systemContent.trim() }); } finalApiMessages.push(...formattedMessages);
            endpoint = 'https://openrouter.ai/api/v1/chat/completions'; headers['Authorization'] = `Bearer ${API_KEYS.openrouter}`; headers['HTTP-Referer'] = `${location.origin}`; headers['X-Title'] = `Auri Chatbot`;
            let effectiveModelId = modelId; if (useWebSearch && modelConfig.supportsWebSearch && modelConfig.webSearchType === 'suffix' && !effectiveModelId.includes(':online')) { effectiveModelId += ':online'; console.log(`Usando modelo com busca web: ${effectiveModelId}`); }
            body = { model: effectiveModelId, messages: finalApiMessages };
            console.log("Enviando para API:", JSON.stringify(body, null, 2));
            const response = await fetch(endpoint, { method: 'POST', headers: headers, body: JSON.stringify(body), signal });
            if (!response.ok) { const errorData = await response.json().catch(() => ({ message: response.statusText })); console.error("Erro da API:", errorData); const errorMessage = errorData?.error?.message || errorData?.message || `Erro ${response.status}`; throw new Error(`Erro API: ${errorMessage}`); }
            const data = await response.json(); console.log("Resposta da API:", data);
            if (data.choices && data.choices[0] && data.choices[0].message) { return data.choices[0].message.content || ''; } else { console.warn("Formato de resposta inesperado da API:", data); throw new Error('Resposta da API em formato inválido.'); }
        };

        // --- Funções de Conteúdo Estático (Termos, Privacidade - Mantido igual) --- //
        const formatPolicyText = (text) => text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
        const getTermsOfUseContent = () => {
            const rawText = `**Termos de Uso - Auri Chatbot**\n\n*Última atualização: ${new Date().toLocaleDateString('pt-BR')}*
         
Bem-vindo ao Auri!
Estes Termos de Uso ("Termos") regem seu acesso e uso do chatbot Auri ("Serviço"). **AO USAR O SERVIÇO, VOCÊ CONCORDA EXPRESSAMENTE COM ESTES TERMOS E RECONHECE QUE O SERVIÇO É FORNECIDO "COMO ESTÁ" ("AS IS"), SEM GARANTIAS DE QUALQUER TIPO.** Se você não concorda com estes Termos, não use o Serviço.

**1. Descrição do Serviço e Natureza Experimental:**
Auri é uma interface de chatbot experimental, fornecida gratuitamente, projetada com foco em privacidade. Ele permite interagir com diferentes modelos de inteligência artificial (IA) fornecidos por APIs de terceiros (como OpenRouter) ou localmente através de softwares como o LM Studio. O Auri não requer cadastro e armazena todo o histórico de conversas e configurações exclusivamente no armazenamento local do seu navegador. **O Auri é um projeto pessoal, não comercial, e pode conter bugs, instabilidades, limitações ou ser descontinuado a qualquer momento sem aviso prévio.**

**2. Uso Aceitável e Responsabilidade do Usuário:**
Você concorda em usar o Auri apenas para fins legais e de acordo com estes Termos. **VOCÊ É O ÚNICO RESPONSÁVEL POR SUAS INTERAÇÕES, PELO CONTEÚDO QUE GERA ATRAVÉS DO SERVIÇO E PELAS DECISÕES TOMADAS COM BASE NAS RESPOSTAS DA IA.** Você concorda em não usar o Serviço para atividades ilegais, prejudiciais, ou que violem os direitos de terceiros.

**3. APIs de Terceiros e Isenção de Responsabilidade:**
O funcionamento do Auri depende **INTEGRALMENTE** do acesso a APIs de modelos de IA de terceiros (OpenRouter). **O USO DESSES MODELOS ESTÁ SUJEITO AOS TERMOS DE SERVIÇO E POLÍTICAS DE PRIVACIDADE DOS RESPECTIVOS PROVEDORES.** O Auri atua **APENAS** como uma interface e **NÃO TEM CONTROLE, NÃO ENDOSSA E NÃO SE RESPONSABILIZA** pelo conteúdo gerado por esses modelos, nem pela disponibilidade, segurança, precisão, práticas de privacidade ou qualquer outro aspecto dessas APIs de terceiros. **Qualquer problema relacionado ao funcionamento ou conteúdo da IA deve ser direcionado ao provedor da API correspondente.**

**4. Privacidade e Dados Locais:**
O Auri foi construído com a privacidade em mente. Nenhum dado de conversa ou configuração pessoal é enviado para servidores do Auri (pois não existem). Todos os dados são armazenados **localmente no seu navegador**. **A SEGURANÇA DESSES DADOS DEPENDE DA SEGURANÇA DO SEU PRÓPRIO DISPOSITIVO E NAVEGADOR.** Se você limpar os dados do seu navegador ou usar a função de limpeza no Auri, **TODOS OS DADOS SERÃO PERMANENTEMENTE PERDIDOS, SEM POSSIBILIDADE DE RECUPERAÇÃO.** As interações enviadas às APIs de terceiros estão sujeitas às políticas de dados desses provedores.

**5. Chaves de API Expostas (Fins Educacionais/Teste):**
**ATENÇÃO:** As chaves de API para serviços externos (OpenRouter) estão **EXPOSTAS DIRETAMENTE NO CÓDIGO FRONTEND**. Isso é feito **APENAS PARA FINS EDUCACIONAIS E DE TESTE**, ciente dos riscos. **NÃO USE ESTE CÓDIGO EM PRODUÇÃO COM ESTAS CHAVES.** O desenvolvedor não se responsabiliza por qualquer uso indevido ou custos gerados por estas chaves.

**6. ISENÇÃO TOTAL DE GARANTIAS:**
**O AURI É FORNECIDO "COMO ESTÁ" E "CONFORME DISPONÍVEL", SEM GARANTIAS DE QUALQUER TIPO, SEJAM EXPRESSAS, IMPLÍCITAS OU ESTATUTÁRIAS.** ISTO INCLUI, MAS NÃO SE LIMITA A, GARANTIAS DE COMERCIALIZAÇÃO, ADEQUAÇÃO A UM FIM ESPECÍFICO, NÃO VIOLAÇÃO, PRECISÃO, CONFIABILIDADE, OU QUE O SERVIÇO SERÁ ININTERRUPTO, SEGURO, LIVRE DE ERROS, VÍRUS OU OUTROS COMPONENTES PREJUDICIAIS.

**7. LIMITAÇÃO MÁXIMA DE RESPONSABILIDADE:**
**EM NENHUMA CIRCUNSTÂNCIA E SOB NENHUMA TEORIA LEGAL (SEJA CONTRATO, ATO ILÍCITO OU OUTRO), O DESENVOLVEDOR DO AURI SERÁ RESPONSÁVEL PERANTE VOCÊ OU QUALQUER TERCEIRO POR QUAISQUER DANOS INDIRETOS, INCIDENTAIS, ESPECIAIS, EXEMPLARES, CONSEQUENCIAIS OU PUNITIVOS, INCLUINDO PERDA DE LUCROS, DADOS, USO, OU OUTRAS PERDAS INTANGÍVEIS, RESULTANTES DE (i) SEU ACESSO OU USO OU INCAPACIDADE DE ACESSAR OU USAR O SERVIÇO; (ii) QUALQUER CONDUTA OU CONTEÚDO DE TERCEIROS NO SERVIÇO, INCLUINDO AS RESPOSTAS DAS APIs DE IA; (iii) ACESSO NÃO AUTORIZADO, USO OU ALTERAÇÃO DE SUAS TRANSMISSÕES OU CONTEÚDO, MESMO QUE O DESENVOLVEDOR TENHA SIDO AVISADO DA POSSIBILIDADE DE TAIS DANOS.** A RESPONSABILIDADE TOTAL DO DESENVOLVEDOR POR TODAS AS REIVINDICAÇÕES RELACIONADAS AO SERVIÇO NÃO EXCEDERÁ, EM HIPÓTESE ALGUMA, O VALOR DE ZERO REAIS (R$ 0,00).

**8. Modificações nos Termos:**
Podemos revisar estes Termos a qualquer momento, a nosso exclusivo critério. A versão mais atual estará sempre disponível no Serviço (através do link nas Configurações). Ao continuar usando o Auri após as alterações entrarem em vigor, você concorda em ficar vinculado aos Termos revisados.

**9. Lei Aplicável:**
Estes Termos serão regidos pelas leis do Brasil.

**10. Contato:**
Este é um projeto pessoal sem suporte formal.`; return formatPolicyText(rawText.trim());
        };
        const getPrivacyPolicyContent = () => {
            const rawText = `**Política de Privacidade - Auri Chatbot**\n\n*Última atualização: ${new Date().toLocaleDateString('pt-BR')}
*Esta Política de Privacidade descreve como o chatbot Auri lida com suas informações.

**1. Informações que Coletamos:**
O Auri **NÃO COLETA** informações de identificação pessoal. Não exigimos nome, e-mail, ou qualquer forma de cadastro.
As únicas informações que o Auri manipula são:
*   **Histórico de Conversas:** As mensagens que você envia e as respostas da IA.
*   **Configurações do Usuário:** Preferências como tema, cor de destaque, idioma, instruções personalizadas e nome opcional.
*   **Estado da Aplicação:** Informações técnicas como o chat atual selecionado e o estado da interface.

**2. Onde as Informações são Armazenadas:**
Todas as informações mencionadas acima (histórico, configurações, estado) são armazenadas **EXCLUSIVAMENTE** no armazenamento local (LocalStorage) do **SEU NAVEGADOR**, no seu dispositivo. Nenhum desses dados é transmitido ou armazenado em servidores externos pertencentes ao Auri.

**3. Como as Informações são Usadas:**
*   **Histórico de Conversas:** Usado para exibir suas conversas anteriores e fornecer contexto para as respostas da IA.
*   **Configurações:** Usadas para personalizar sua experiência de uso do Auri (aparência, comportamento da IA).
*   **Estado da Aplicação:** Usado para manter a funcionalidade da interface (saber qual chat mostrar, etc.).

**4. Compartilhamento de Informações:**
Nós **NÃO COMPARTILHAMOS** seus dados armazenados localmente com terceiros.
No entanto, para que o Auri funcione, as mensagens que você envia (e o histórico relevante da conversa atual, juntamente com instruções personalizadas) são enviadas para as APIs de modelos de IA de terceiros (OpenRouter). O tratamento dessas informações por esses provedores terceirizados é regido por suas próprias políticas de privacidade. Recomendamos que você revise as políticas de privacidade dos provedores de API que utiliza.

**5. Segurança:**
Embora armazenemos os dados apenas localmente no seu dispositivo, a segurança desses dados depende da segurança do seu próprio navegador e dispositivo. As chaves de API para serviços externos (OpenRouter) estão atualmente incorporadas no código frontend; isso é feito para fins de demonstração e facilidade de uso neste contexto experimental, mas **não é uma prática segura para produção**. Qualquer pessoa com acesso ao código-fonte pode ver essas chaves.
As comunicações com as APIs externas (OpenRouter) geralmente ocorrem sobre HTTPS, mas a segurança ponta-a-ponta depende das práticas desses provedores.

**6. Seus Direitos e Controle:**
Você tem controle total sobre os dados armazenados localmente. Você pode:
*   **Excluir Chats:** Excluir conversas individuais através da interface (botão 🗑️ ao lado do nome do chat).
*   **Limpar Todos os Dados:** Usar o botão "Limpar Todos os Dados Locais" nas configurações para remover permanentemente todo o histórico e todas as configurações do Auri do seu navegador.
*   **Limpar Dados do Navegador:** Limpar o cache e os dados de site do seu navegador também removerá todos os dados do Auri.

**7. Cookies:**
O Auri não utiliza cookies para rastreamento ou funcionalidade principal. O armazenamento local é usado em vez de cookies para persistência de dados.

**8. Alterações nesta Política:**
Podemos atualizar esta Política de Privacidade ocasionalmente. Quaisquer alterações serão refletidas aqui com uma data de "Última atualização" revisada, acessível através do link nas Configurações.

**9. Contato:**
Se tiver alguma dúvida sobre esta Política de Privacidade, pode buscar contato através dos canais onde o projeto foi divulgado (se aplicável).`; return formatPolicyText(rawText.trim());
        };
        const showPolicyModal = (type) => { const titleKey = type === 'terms' ? 'termsLink' : 'privacyLink'; const content = type === 'terms' ? getTermsOfUseContent() : getPrivacyPolicyContent(); const policyModalTitle = document.getElementById('policy-modal-title'); const policyModalBody = document.getElementById('policy-modal-body'); if (policyModalTitle) policyModalTitle.textContent = t[titleKey] || titleKey; if (policyModalBody) policyModalBody.innerHTML = content; policyModal.classList.add('visible'); };

        // --- Inicialização e Listeners (Mantido igual) --- //
        const initializeSettings = () => {
            applyTheme(state.settings.theme); applyAccentColor(state.settings.accentColor); aiLangSelect.value = state.settings.aiLang; userNameInput.value = state.settings.userName; customInstructionsTextarea.value = state.settings.customInstructions;
            aiLangSelect.addEventListener("change", (e) => { state.settings.aiLang = e.target.value; saveState(); }); userNameInput.addEventListener("input", (e) => { state.settings.userName = e.target.value; saveState(); }); customInstructionsTextarea.addEventListener("input", (e) => { state.settings.customInstructions = e.target.value; saveState(); });
            suggestionBtns.forEach(btn => { btn.addEventListener('click', () => { customInstructionsTextarea.value += (customInstructionsTextarea.value ? '\n' : '') + btn.dataset.suggestion; state.settings.customInstructions = customInstructionsTextarea.value; saveState(); }); });
            colorOptionsContainer.querySelectorAll('.color-option').forEach(option => { option.addEventListener('click', () => { applyAccentColor(option.dataset.color); saveState(); }); });
            themeToggleBtn.addEventListener('click', () => { const newTheme = state.settings.theme === 'light' ? 'dark' : 'light'; applyTheme(newTheme); saveState(); });
            clearDataBtn.addEventListener('click', () => {
                showModal('modalConfirmClearDataTitle', t.modalConfirmClearDataBody, [{ text: 'modalCancel', class: '', onClick: () => closeModal('generic-modal') }, { text: 'modalConfirmClearDataButton', class: 'danger', onClick: () => { localStorage.removeItem('auriState'); const agreed = state.settings.agreedToTerms; state = { chats: {}, currentChatId: null, settings: { theme: 'dark', accentColor: '#3b82f6', aiLang: 'auto', userName: '', customInstructions: '', agreedToTerms: agreed, dailyMessageCount: 0, lastMessageDate: null }, isAiResponding: false, webSearchActive: false, attachedImage: null }; initializeAppUI(); closeModal('generic-modal'); closeModal('settings-modal'); showModal('modalSuccessTitle', 'Todos os dados locais foram limpos com sucesso.'); } }], 'generic-modal');
            });
            settingsTermsLink.addEventListener('click', (e) => { e.preventDefault(); showPolicyModal('terms'); }); settingsPrivacyLink.addEventListener('click', (e) => { e.preventDefault(); showPolicyModal('privacy'); });
            updateMessageLimitDisplay();
        };
        const initializeAppUI = () => {
            initializeSettings(); applyTranslations(); renderChatList();
            if (state.currentChatId && state.chats[state.currentChatId]) { renderMessages(state.currentChatId); }
            else { const sortedIds = Object.keys(state.chats).sort((a, b) => state.chats[b].createdAt - state.chats[a].createdAt); if (sortedIds.length > 0) { selectChat(sortedIds[0]); } else if (state.settings.agreedToTerms) { createNewChat(false); } }
            updateInputButtonsState(); adjustTextareaHeight(); sidebarToggleBtn.classList.toggle('outside', sidebar.classList.contains('collapsed')); sidebarToggleBtn.textContent = sidebar.classList.contains('collapsed') ? '☰' : '✕';
        };
        const initializeApp = () => {
            loadState();
            if (!state.settings.agreedToTerms) { agreementModal.classList.add('visible'); } else { initializeAppUI(); }
            sidebarToggleBtn.addEventListener('click', () => { const isCollapsed = sidebar.classList.toggle('collapsed'); sidebarToggleBtn.classList.toggle('outside', isCollapsed); sidebarToggleBtn.textContent = isCollapsed ? '☰' : '✕'; });
            newChatBtn.addEventListener('click', createNewChat); settingsBtn.addEventListener('click', () => { updateMessageLimitDisplay(); settingsModal.classList.add('visible'); });
            document.querySelectorAll('[data-modal-close]').forEach(btn => { btn.addEventListener('click', () => closeModal(btn.dataset.modalClose)); });
            document.querySelectorAll('.modal-overlay').forEach(ov => { ov.addEventListener('click', (e) => { if (e.target === ov && ov.id !== 'agreement-modal' && ov.id !== 'loading-overlay' && ov.id !== 'fullscreen-image-overlay') { closeModal(ov.id); } }); });
            messageInput.addEventListener('input', () => { adjustTextareaHeight(); updateInputButtonsState(); }); messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } if (emptyChatState.style.display !== 'none') { emptyChatState.style.display = 'none'; messageList.style.display = 'flex'; } });
            sendBtn.addEventListener('click', handleSendMessage); attachBtn.addEventListener('click', () => fileInput.click()); fileInput.addEventListener('change', handleFileUpload); removeAttachmentBtn.addEventListener("click", removeAttachment); webSearchBtn.addEventListener('click', () => { if (MODEL_CONFIG.supportsWebSearch) { state.webSearchActive = !state.webSearchActive; updateInputButtonsState(); } });
            agreeBtn.addEventListener('click', () => { state.settings.agreedToTerms = true; closeModal('agreement-modal'); initializeAppUI(); saveState(); });
            agreementTermsLink.addEventListener('click', (e) => { e.preventDefault(); showPolicyModal('terms'); }); agreementPrivacyLink.addEventListener('click', (e) => { e.preventDefault(); showPolicyModal('privacy'); });
            stopGenerationBtn.addEventListener('click', () => { if (currentRequestController) { currentRequestController.abort(); console.log("Tentando interromper a geração..."); } });
            fullscreenImageOverlay.addEventListener('click', hideFullscreenImage);
            document.addEventListener('click', (e) => { if (window.innerWidth <= 768 && !sidebar.classList.contains('collapsed')) { if (!sidebar.contains(e.target) && !sidebarToggleBtn.contains(e.target)) { sidebar.classList.add('collapsed'); sidebarToggleBtn.classList.add('outside'); sidebarToggleBtn.textContent = '☰'; } } });
        };

        // Inicia a aplicação
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>

</body>

</html>
